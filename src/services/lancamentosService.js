import { 
  collection, 
  addDoc, 
  getDocs, 
  query, 
  where, 
  Timestamp,
  doc,
  updateDoc
} from 'firebase/firestore';
import { db } from '../firebase/config';

export const lancamentosService = {
  // Criar um novo lan√ßamento (receita ou despesa)
  async criarLancamento(dadosLancamento) {
    try {
      console.log('üí∞ Criando lan√ßamento:', dadosLancamento);
      
      // Verificar se o usu√°rio est√° autenticado
      const { auth } = await import('../firebase/config');
      if (!auth.currentUser) {
        throw new Error('Usu√°rio n√£o autenticado. Fa√ßa login para criar lan√ßamentos.');
      }
      
      const lancamento = {
        ...dadosLancamento,
        dataLancamento: Timestamp.fromDate(new Date(dadosLancamento.data)),
        dataCriacao: Timestamp.now(),
        status: 'ATIVO',
        criadoPor: auth.currentUser.uid, // Adicionar ID do usu√°rio
        emailCriador: auth.currentUser.email // Adicionar email do criador
      };
      
      const docRef = await addDoc(collection(db, 'lancamentos'), lancamento);
      console.log('‚úÖ Lan√ßamento criado com ID:', docRef.id);
      
      return {
        id: docRef.id,
        ...lancamento
      };
    } catch (error) {
      console.error('‚ùå Erro ao criar lan√ßamento:', error);
      
      if (error.code === 'permission-denied') {
        throw new Error('Sem permiss√£o para criar lan√ßamentos. Verifique as configura√ß√µes do Firebase.');
      }
      
      throw new Error(`Erro ao salvar lan√ßamento: ${error.message}`);
    }
  },

  // Buscar lan√ßamentos por filtros
  async buscarLancamentos(filtros = {}) {
    try {
      console.log('üîç Buscando lan√ßamentos com filtros:', filtros);
      
      // Verificar se o usu√°rio est√° autenticado
      const { auth } = await import('../firebase/config');
      if (!auth.currentUser) {
        console.warn('‚ö†Ô∏è Usu√°rio n√£o autenticado, retornando lista vazia de lan√ßamentos');
        return [];
      }
      
      // BUSCA SIMPLES: Buscar TODOS os lan√ßamentos ativos e filtrar no cliente
      console.log('üîç Fazendo busca simples de todos os lan√ßamentos ativos...');
      let q = query(collection(db, 'lancamentos'), where('status', '==', 'ATIVO'));
      
      const querySnapshot = await getDocs(q);
      const lancamentos = [];
      
      querySnapshot.forEach((doc) => {
        const data = doc.data();
        lancamentos.push({
          id: doc.id,
          ...data,
          // Converter Timestamp para Date
          data: data.dataLancamento?.toDate?.() || new Date(),
          dataCriacao: data.dataCriacao?.toDate?.() || new Date()
        });
      });
      
      console.log(`‚úÖ ${lancamentos.length} lan√ßamentos encontrados no total`);
      
      // Aplicar filtros no cliente
      let lancamentosFiltrados = lancamentos;
      
      // Filtro por unidade
      if (filtros.unidade && filtros.unidade !== 'all') {
        lancamentosFiltrados = lancamentosFiltrados.filter(lancamento => 
          lancamento.unidade === filtros.unidade
        );
        console.log(`üè¢ ${lancamentosFiltrados.length} lan√ßamentos ap√≥s filtro de unidade (${filtros.unidade})`);
      }
      
      // Filtro por tipo
      if (filtros.tipo) {
        lancamentosFiltrados = lancamentosFiltrados.filter(lancamento => 
          lancamento.tipo === filtros.tipo
        );
        console.log(`üìä ${lancamentosFiltrados.length} lan√ßamentos ap√≥s filtro de tipo (${filtros.tipo})`);
      }
      
      if (filtros.dataInicial && filtros.dataFinal) {
        const dataIni = new Date(filtros.dataInicial);
        const dataFim = new Date(filtros.dataFinal);
        dataFim.setHours(23, 59, 59, 999);
        
        lancamentosFiltrados = lancamentos.filter(lancamento => {
          const dataLancamento = new Date(lancamento.data);
          return dataLancamento >= dataIni && dataLancamento <= dataFim;
        });
        
        console.log(`üìÖ ${lancamentosFiltrados.length} lan√ßamentos ap√≥s filtro de data`);
      }
      
      return lancamentosFiltrados;
    } catch (error) {
      console.error('‚ùå Erro ao buscar lan√ßamentos:', error);
      
      // Se for erro de permiss√£o, retornar array vazio em vez de falhar
      if (error.code === 'permission-denied' || error.message.includes('Missing or insufficient permissions')) {
        console.warn('‚ö†Ô∏è Sem permiss√£o para acessar lan√ßamentos, retornando lista vazia');
        return [];
      }
      
      // Para outros erros, retornar array vazio tamb√©m para n√£o quebrar a aplica√ß√£o
      console.warn('‚ö†Ô∏è Erro ao buscar lan√ßamentos, retornando lista vazia');
      return [];
    }
  },

  // Atualizar um lan√ßamento
  async atualizarLancamento(id, dadosAtualizacao) {
    try {
      console.log('üìù Atualizando lan√ßamento:', id, dadosAtualizacao);
      
      const lancamentoRef = doc(db, 'lancamentos', id);
      const dadosParaAtualizar = {
        ...dadosAtualizacao,
        dataAtualizacao: Timestamp.now()
      };
      
      // Se a data foi alterada, converter para Timestamp
      if (dadosAtualizacao.data) {
        dadosParaAtualizar.dataLancamento = Timestamp.fromDate(new Date(dadosAtualizacao.data));
        delete dadosParaAtualizar.data; // Remove a data em formato string
      }
      
      await updateDoc(lancamentoRef, dadosParaAtualizar);
      console.log('‚úÖ Lan√ßamento atualizado com sucesso');
      
      return true;
    } catch (error) {
      console.error('‚ùå Erro ao atualizar lan√ßamento:', error);
      throw new Error(`Erro ao atualizar lan√ßamento: ${error.message}`);
    }
  },

  // Excluir um lan√ßamento (soft delete)
  async excluirLancamento(id) {
    try {
      console.log('üóëÔ∏è Excluindo lan√ßamento:', id);
      
      const lancamentoRef = doc(db, 'lancamentos', id);
      await updateDoc(lancamentoRef, {
        status: 'EXCLUIDO',
        dataExclusao: Timestamp.now()
      });
      
      console.log('‚úÖ Lan√ßamento exclu√≠do com sucesso');
      return true;
    } catch (error) {
      console.error('‚ùå Erro ao excluir lan√ßamento:', error);
      throw new Error(`Erro ao excluir lan√ßamento: ${error.message}`);
    }
  },

  // Atualizar status de lan√ßamento baseado no status da conta BTG
  async atualizarStatusContaBTG(contaBTGId, novoStatus) {
    try {
      console.log('üîÑ Atualizando status de lan√ßamentos da conta BTG:', contaBTGId, 'para:', novoStatus);
      
      // Buscar lan√ßamentos relacionados √† conta BTG
      const q = query(
        collection(db, 'lancamentos'), 
        where('contaBTGId', '==', contaBTGId),
        where('status', '==', 'ATIVO')
      );
      
      const querySnapshot = await getDocs(q);
      const atualizacoes = [];
      
      querySnapshot.forEach((doc) => {
        const lancamentoRef = doc.ref;
        let novaDescricao = doc.data().descricao;
        
        // Atualizar descri√ß√£o baseada no status
        if (novoStatus === 'PAGO') {
          novaDescricao = novaDescricao.replace('[AGUARDANDO]', '[PAGO]');
        } else if (novoStatus === 'CANCELADO') {
          novaDescricao = novaDescricao.replace('[AGUARDANDO]', '[CANCELADO]');
        } else if (novoStatus === 'AGUARDANDO') {
          novaDescricao = novaDescricao.replace(/\[(PAGO|CANCELADO)\]/, '[AGUARDANDO]');
        }
        
        const atualizacao = updateDoc(lancamentoRef, {
          descricao: novaDescricao,
          statusContaBTG: novoStatus,
          dataUltimaAlteracao: Timestamp.now()
        });
        
        atualizacoes.push(atualizacao);
      });
      
      await Promise.all(atualizacoes);
      console.log(`‚úÖ ${atualizacoes.length} lan√ßamentos atualizados`);
      
      return atualizacoes.length;
    } catch (error) {
      console.error('‚ùå Erro ao atualizar status dos lan√ßamentos:', error);
      throw new Error(`Erro ao atualizar status dos lan√ßamentos: ${error.message}`);
    }
  },

  // Buscar estat√≠sticas dos lan√ßamentos
  async buscarEstatisticas(filtros = {}) {
    try {
      console.log('Calculando estat√≠sticas dos lan√ßamentos');
      
      const lancamentos = await this.buscarLancamentos(filtros);
      
      const estatisticas = {
        totalReceitas: 0,
        totalDespesas: 0,
        saldoLancamentos: 0,
        quantidadeReceitas: 0,
        quantidadeDespesas: 0,
        totalTransacoes: 0
      };
      
      lancamentos.forEach(lancamento => {
        const valor = parseFloat(lancamento.valor) || 0;
        
        if (lancamento.tipo === 'RECEITA') {
          estatisticas.totalReceitas += valor;
          estatisticas.quantidadeReceitas++;
        } else if (lancamento.tipo === 'DESPESA') {
          estatisticas.totalDespesas += valor;
          estatisticas.quantidadeDespesas++;
        }
        
        estatisticas.totalTransacoes++;
      });
      
      estatisticas.saldoLancamentos = estatisticas.totalReceitas - estatisticas.totalDespesas;
      
      console.log('Estat√≠sticas calculadas:', estatisticas);
      return estatisticas;
    } catch (error) {
      console.error('‚ùå Erro ao calcular estat√≠sticas:', error);
      throw new Error(`Erro ao calcular estat√≠sticas: ${error.message}`);
    }
  },

  // Formatar lan√ßamento para exibi√ß√£o (compat√≠vel com extratos)
  formatarParaExtrato(lancamento) {
    // Determinar status baseado no statusContaBTG ou status padr√£o
    let statusFinal = 'CONFIRMADO';
    if (lancamento.statusContaBTG) {
      switch (lancamento.statusContaBTG) {
        case 'AGUARDANDO':
          statusFinal = 'AGUARDANDO';
          break;
        case 'PAGO':
          statusFinal = 'CONFIRMADO';
          break;
        case 'CANCELADO':
          statusFinal = 'CANCELADO';
          break;
        default:
          statusFinal = 'CONFIRMADO';
      }
    } else if (lancamento.categoria === 'CONTA_BTG') {
      // Se √© conta BTG mas n√£o tem statusContaBTG, assumir AGUARDANDO
      statusFinal = 'AGUARDANDO';
    }

    return {
      id: lancamento.id, // Usar ID original para permitir exclus√£o
      data: lancamento.data,
      date: lancamento.data,
      descricao: lancamento.descricao,
      description: lancamento.descricao,
      tipo: lancamento.tipo,
      type: lancamento.tipo === 'RECEITA' ? 'CREDIT' : 'DEBIT',
      valor: parseFloat(lancamento.valor) || 0,
      value: parseFloat(lancamento.valor) || 0,
      status: statusFinal,
      origem: 'LANCAMENTO_MANUAL',
      categoria: lancamento.categoria || 'OUTROS',
      unidade: lancamento.unidade,
      cliente: 'Lan√ßamento Manual',
      formaPagamento: lancamento.formaPagamento || 'N/A',
      observacoes: lancamento.observacoes || '',
      fonte: 'firebase' // Marcar como lan√ßamento manual do Firebase
    };
  },

  // Validar dados do lan√ßamento
  validarLancamento(dados) {
    const erros = [];
    
    if (!dados.descricao || dados.descricao.trim() === '') {
      erros.push('Descri√ß√£o √© obrigat√≥ria');
    }
    
    if (!dados.valor || parseFloat(dados.valor) <= 0) {
      erros.push('Valor deve ser maior que zero');
    }
    
    if (!dados.data) {
      erros.push('Data √© obrigat√≥ria');
    }
    
    if (!dados.tipo || !['RECEITA', 'DESPESA'].includes(dados.tipo)) {
      erros.push('Tipo deve ser RECEITA ou DESPESA');
    }
    
    if (!dados.unidade || dados.unidade.trim() === '') {
      erros.push('Unidade √© obrigat√≥ria');
    }
    
    return erros;
  },

  // Excluir lan√ßamentos relacionados a uma conta BTG
  async excluirLancamentosPorContaBTG(contaBTGId) {
    try {
      console.log('üóëÔ∏è Excluindo lan√ßamentos relacionados √† conta BTG:', contaBTGId);
      
      // Verificar se o usu√°rio est√° autenticado
      const { auth } = await import('../firebase/config');
      if (!auth.currentUser) {
        throw new Error('Usu√°rio n√£o autenticado.');
      }
      
      // Buscar lan√ßamentos relacionados √† conta BTG
      const q = query(
        collection(db, 'lancamentos'), 
        where('contaBTGId', '==', contaBTGId),
        where('status', '==', 'ATIVO')
      );
      
      const querySnapshot = await getDocs(q);
      const exclusoes = [];
      
      querySnapshot.forEach((doc) => {
        const lancamentoRef = doc.ref;
        const exclusao = updateDoc(lancamentoRef, {
          status: 'EXCLUIDO',
          dataExclusao: Timestamp.now(),
          excluidoPor: auth.currentUser.uid,
          emailExclusor: auth.currentUser.email,
          motivoExclusao: 'Conta BTG exclu√≠da'
        });
        
        exclusoes.push(exclusao);
      });
      
      await Promise.all(exclusoes);
      console.log(`‚úÖ ${exclusoes.length} lan√ßamentos relacionados exclu√≠dos`);
      
      return exclusoes.length;
    } catch (error) {
      console.error('‚ùå Erro ao excluir lan√ßamentos relacionados:', error);
      throw new Error(`Erro ao excluir lan√ßamentos relacionados: ${error.message}`);
    }
  }
};

export default lancamentosService; 